### **455. 分发饼干**

------

#### 📜 题目描述

假设你是一位小朋友，总共有若干个小朋友排队，每个小朋友有一个“胃口值” `g[i]`，表示他至少需要这么大尺寸的饼干才能满足。你还有若干块饼干，每块饼干的大小用数组 `s[j]` 表示。每个小朋友至多分配一块饼干，分配给他的饼干尺寸 ≥ 他的胃口，才能让他满足。问最多能满足多少小朋友？

- `0 ≤ g.length, s.length ≤ 10⁴`
- 胃口值和饼干尺寸均为非负整数

------

#### 💡 贪心解法思路

1. **排序**
   - 将胃口数组 `g` 从小到大排序；
   - 将饼干尺寸数组 `s` 从小到大排序。
2. **双指针从大到小匹配**
   - 用 `gIndex = g.length-1` 指向当前未满足的胃口最大的小朋友；
   - 用 `sIndex = s.length-1` 指向当前最大的饼干；
   - 如果 `s[sIndex] ≥ g[gIndex]`，说明最大饼干能满足当前最贪心的小朋友，满足数 `result++`，同时两指针都左移；
   - 否则，最大饼干都不够，移去这个小朋友 `gIndex--` 继续尝试下一个胃口较小的小朋友。
3. **终止条件**
   - `gIndex < 0`（所有小朋友都被考虑过）或 `sIndex < 0`（没有饼干可分配）时结束。

该策略能 **最大化** 满足的人数，因为：

- 总是用当前最大的饼干去满足当前最难满足的孩子，避免大饼干白白浪费在胃口小的孩子身上。

------

#### ✅ 代码实现（带中文注释）

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        // 1. 对胃口和饼干尺寸排序
        Arrays.sort(g);
        Arrays.sort(s);

        int result = 0;                  // 已满足的小朋友数量
        int gIndex = g.length - 1;       // 指向当前最大胃口的小朋友
        int sIndex = s.length - 1;       // 指向当前最大尺寸的饼干

        // 2. 从最大胃口和最大饼干开始匹配
        while (gIndex >= 0 && sIndex >= 0) {
            if (s[sIndex] >= g[gIndex]) {
                // 最大饼干能满足该小朋友
                result++;
                sIndex--;   // 该饼干分配掉
                gIndex--;   // 该小朋友满足
            } else {
                // 最大饼干不足以满足该最贪心的小朋友
                // 只能尝试下一个胃口更小的小朋友
                gIndex--;
            }
        }

        return result;
    }
}
```

------

#### ⏱ 复杂度分析

- **时间复杂度**：
  - 排序两数组各 `O(n log n + m log m)`（`n = g.length`, `m = s.length`）
  - 双指针扫描 `O(n + m)`
     综合：`O(n log n + m log m)`
- **空间复杂度**：
  - 排序原地进行，额外常数级空间，`O(1)`（或 `O(log n + log m)` 用于排序栈）。

------

#### 🔚 小结

- **贪心策略**：总是用最大的饼干去喂胃口最大的未满足小朋友；
- **双指针**从尾部向前扫描，简洁高效；
- 先排序，才能保证匹配正确的贪心顺序。