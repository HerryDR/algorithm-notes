### **376. 摆动序列**

------

#### 🧾 题目描述

给定一个整数数组 `nums`，如果相邻元素之间的差值交替正负（即“摆动”），则称该数组为摆动序列。

- 相邻两元素差值不能为 0；
- 差值的正负交替出现。

求 `nums` 的 **最长摆动子序列** 的长度。子序列不要求连续，但需保持相对顺序。

------

#### 💡 贪心解法思路

维护两个状态变量：

- `up`：以正向差（上升）结尾的最长摆动长度；
- `down`：以负向差（下降）结尾的最长摆动长度。

开始时，单个元素既算作上升也算作下降，都初始化为 `1`。从第二个元素往后遍历：

1. 如果 `nums[i] > nums[i−1]`，说明出现一次“上升摆动”，可以把之前以下降结尾的序列再加上这次上升：

   ```java
   up = down + 1;
   ```

2. 如果 `nums[i] < nums[i−1]`，说明出现一次“下降摆动”，可以把之前以上升结尾的序列再加上这次下降：

   ```java
   down = up + 1;
   ```

3. 相等时既不能上升也不能下降，二者保持不变。

最终答案即为 `max(up, down)`，表示以任一方向结尾的最长摆动序列。

------

#### ✅ 代码实现（带中文注释）

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        // 少于 2 个元素时，本身就是摆动序列
        if (n < 2) {
            return n;
        }

        // up：以正向差结尾的最长摆动长度
        // down：以负向差结尾的最长摆动长度
        int up = 1, down = 1;

        // 从第 2 个元素开始遍历
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                // 出现“上升”摆动
                up = down + 1;
            } else if (nums[i] < nums[i - 1]) {
                // 出现“下降”摆动
                down = up + 1;
            }
            // 相等时不做任何更新
        }

        // 最长摆动序列要么以上升结尾，要么以下降结尾
        return Math.max(up, down);
    }
}
```

------

#### ⏱ 时间复杂度

- **O(n)**，只遍历一次数组。

#### 🧮 空间复杂度

- **O(1)**，只使用常数级额外空间（两个整型变量 `up` 和 `down`）。

------

#### 🔚 小结

- 用 **双变量贪心** 维护「上升/下降」两种结尾情况；
- 每次上升就更新 `up = down + 1`，每次下降就更新 `down = up + 1`；
- 简洁高效，一次遍历即可完成。