### **216. 组合总和 III**

------

#### 题目解析

给定两个整数 `k` 和 `n`，要求从数字 **1 到 9** 中选出 **k** 个不同的数字，这些数字的和恰好为 `n`。
 要求：

- 每个数字最多只能使用一次。
- 不能出现重复的组合。
- 最终返回所有满足条件的组合列表（顺序不限）。

------

#### 解题思路

本题是一个典型的 **组合问题**，可以用 **回溯算法** 来解决，思路如下：

1. **递归构建组合**

   - 从数字 1 开始，逐步构造可能的组合，并记录当前组合的和 `sum`。
   - 每一次选取数字后，将数字加入当前组合 `path` 中，同时累加到 `sum`。

2. **剪枝策略**

   - 如果当前 `sum` 超过目标 `n`，则没有必要继续搜索，直接返回（剪枝）。

   - 通过剪枝条件 `if (sum > n)` 可以提前返回，减少不必要的递归调用。

   - 另外，对于循环迭代时，我们采用剪枝条件：

     ```
     i <= 9 - (k - path.size()) + 1
     ```

     该条件确保从当前起点到 9 剩余的数字足够凑成长度为 k 的组合，否则可以提前停止。

3. **终止条件**

   - 当当前组合 `path` 的长度达到 `k` 时：
     - 如果累加和 `sum` 等于目标 `n`，说明找到了一个合法组合，将其加入结果列表 `result`；
     - 否则，返回并撤销上一步选择。

4. **回溯**

   - 在递归返回前，通过 `path.removeLast()` 和调整 `sum` 来撤销最近的选择，回溯到上一层状态，尝试其他数字。

------

#### 代码实现

```java
class Solution {
    // 全局变量：存储所有符合条件的组合结果
    private List<List<Integer>> result = new ArrayList<>();
    // 当前组合的数字
    private List<Integer> path = new ArrayList<>();
    // 当前组合数字的累计和
    private int sum = 0;
    
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(n, k, 1); // 从数字 1 开始搜索
        return result;
    }
    
    private void backtracking(int n, int k, int startIndex) {
        // 如果当前累计和大于目标值 n，剪枝，直接返回
        if (sum > n) {
            return;
        }
        
        // 当组合长度达到 k 时，检查是否满足累计和等于 n 的条件
        if (path.size() == k) {
            if (sum == n) {
                result.add(new ArrayList<>(path)); // 将当前组合的副本加入结果列表
            }
            return;
        }
        
        // 循环选择从 startIndex 开始的数字
        // 剪枝条件：剩余数字不足以凑满 k 个时直接返回
        for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
            path.add(i);      // 选择当前数字 i
            sum += i;         // 更新当前累计和
            backtracking(n, k, i + 1);  // 递归：从 i+1 开始选择下一个数字
            path.remove(path.size() - 1); // 回溯：撤销选择，移除最后一个数字
            sum -= i;         // 恢复累计和
        }
    }
}
```

------

#### 复杂度分析

- **时间复杂度**：
   最坏情况下需要生成所有符合条件的组合，时间复杂度为 O(C(9, k))（组合总数），其中 k 最大为 9；实际执行中由于剪枝操作会减少很多无效递归，效率较高。
- **空间复杂度**：
  - 递归调用栈的深度为 k，空间复杂度为 O(k)。
  - 存储结果列表的空间复杂度为 O(C(9, k) * k)。

------

#### 总结

- **核心思想**：
   使用回溯算法在数字 1 到 9 中选出 k 个数字，并维护一个累计和，在递归过程中进行剪枝和回溯，最终构造出所有满足组合和为 n 的组合。
- **剪枝**：
   如果剩余的数字不足以凑满 k 个数字（通过 `i <= 9 - (k - path.size()) + 1` 条件判断），则提前停止递归。
- **回溯**：
   每次递归返回前撤销上一次选择，恢复组合状态，保证其他路径的正确计算。

这样就可以高效地解决组合问题，同时防止重复组合的产生。