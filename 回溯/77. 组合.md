### **77. 组合 — 笔记**

#### 题目解析

给定两个整数 **n** 和 **k**，要求返回从 **1** 到 **n** 中所有可能的 **k** 个数的组合。
 例如，当 n = 4, k = 2 时，可能的组合有：

```
[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]
```

------

#### 解题思路

本题是一个典型的组合问题，适合用回溯算法来解决。

- **回溯算法**：

  - 通过递归逐步构建组合，在每一步选择一个数字，并继续选择下一个数字，直到组合中有 k 个数。
  - 使用一个列表 `path` 存储当前构建的组合；当组合长度等于 k 时，把组合的拷贝加入结果列表 `result`。
  - 回溯过程中，需要撤销上一次的选择（即删除最后一个加入的数字），以尝试其他数字。

- **剪枝优化**：

  - 在 `for` 循环中，可以提前终止，当从当前的起始数字到 n 的剩余数字数量不足以填满 k 个数时，就没有必要再进行递归。

  - 具体剪枝条件为：

    ```
    i <= n - (k - path.size()) + 1
    ```

    这确保了在当前已选 `path.size()` 个数字的情况下，剩余的数字足够凑成一个长度为 k 的组合。

------
**单层搜索的过程**

![回溯单层搜索过程](image/回溯单层搜索过程.png)

#### 代码实现（带中文注释）

```java
class Solution {
    // 全局变量：用于存储当前构建的组合
    List<Integer> path = new ArrayList<>();
    // 全局变量：用于存储所有满足条件的组合结果
    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(n, k, 1); // 从1开始选数
        return result;
    }

    private void backtracking(int n, int k, int startIndex) {
        // 当当前组合长度达到 k 时，将组合加入结果中
        if (path.size() == k) {
            result.add(new ArrayList<>(path));
            return;
        }
        // 剪枝：如果剩余可选的数字数量不足以凑满 k 个，则提前返回
        // 这里 i 的最大值为 n - (k - path.size()) + 1
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
            path.add(i);                     // 选择当前数字 i 加入组合中
            backtracking(n, k, i + 1);         // 递归调用，从 i+1 继续选数
            path.remove(path.size() - 1);      // 回溯，撤销最后一次选择
        }
    }
}
```

------

#### 复杂度分析

- **时间复杂度**：
   最坏情况下，生成的组合数为 C(n, k)（组合数），每个组合需要 O(k) 的时间来构造，所以总体时间复杂度为 O(C(n, k) * k)。
- **空间复杂度**：
  - 递归调用栈的深度为 O(k)（因为当前组合的最大长度为 k）。
  - 存储结果需要 O(C(n, k) * k) 的空间，除此之外额外使用的空间较小。

------

#### 总结

1. **核心思路**：
   - 使用回溯算法从数字 1 开始逐步构建组合。
   - 利用剪枝条件，减少不必要的递归调用，提高算法效率。
2. **关键步骤**：
   - 当组合长度达到 k 时，将当前组合（副本）加入结果列表。
   - 在每次递归返回时，通过回溯撤销上一次选择，确保路径正确。
3. **优化策略**：
   - 使用剪枝条件 `i <= n - (k - path.size()) + 1`，确保在剩余数字不足时提前结束当前递归分支，从而减少计算量。